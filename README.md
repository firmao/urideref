# URI dereferenceable
This demonstrates how to make URIs dereferenceable and generate RDF content dynamically by querying a triple store in Python using Flask and SPARQL.

A URI (Uniform Resource Identifier) is dereferenceable if it can be used to retrieve a resource over the web, typically via HTTP or HTTPS. To make a URI dereferenceable, follow these steps:

1. Assign a URI to a Resource
A URI should represent a specific resource, such as a webpage, an image, a document, or even a piece of data in a knowledge graph. Ensure the URI is well-formed and unique.
2. Configure a Web Server
Set up a web server (such as Apache, Nginx, or any other web server) to host the resource.
The web server should be configured to handle HTTP/HTTPS requests for that URI.
3. Map the URI to a Resource
Map the URI to the resource you want to serve. This can be a file (e.g., example.com/resource.jpg) or dynamic content generated by the server.
4. Respond with Appropriate HTTP Status Codes
200 OK: If the resource exists and can be directly retrieved, return the content with a 200 status code.
301/302 Redirect: If the URI is meant to point to another URI, configure an HTTP redirect.
303 See Other: If the URI represents a non-information resource (e.g., a concept, not a document), use a 303 redirect to another URI that provides more information about the resource.
5. Return Useful Metadata (Optional)
In the HTTP headers or within the response body, include metadata that describes the resource. For Linked Data, this could be RDF, JSON-LD, or other machine-readable formats.
Example for Linked Data Dereferencing:
If a URI represents a concept (e.g., a person or a place in a knowledge graph), it should redirect to a document that describes the resource.
For instance, if the URI http://example.com/person/123 represents a person, the server might return a 303 redirect to http://example.com/person/123.html, which provides human-readable information about that person.
Summary:
To make a URI dereferenceable, ensure it can be resolved to an actual resource by configuring a web server to respond to HTTP/HTTPS requests for that URI, and return appropriate status codes and content.

## Running the code (simple one):
```
pip install Flask SPARQLWrapper rdflib
```
Run the script: ```python first.py```.

Open a browser and go to ```http://localhost:5000/person/1``` to see the dereferencing in action.

On GitHub's codespace, add ```/person/1``` to the URL.

# With a triple store:
## Explanation for derefTStore.py:
**SPARQLWrapper**: This library sends SPARQL queries to the triple store (a SPARQL endpoint, in this case). We use the ```CONSTRUCT``` query to retrieve RDF triples related to a person and return the data in Turtle format.

**SPARQL Query**: The query dynamically constructs RDF triples about a person (name, age, and occupation) from the triple store using the ```foaf:name, ex:age, and ex:occupation``` properties.

**SPARQL Endpoint**: The SPARQL_ENDPOINT variable points to your triple store. In this example, it is assumed you are using a local instance of a triple store (e.g., GraphDB, Blazegraph, or Fuseki) at ```http://localhost:7200/repositories/my-repo```.

**Returning Turtle Format**: The query results are returned in Turtle format, and the Flask app sends them back with the appropriate ```MIME type (text/turtle)```.

## Triple Store Setup:
For this to work, you need a triple store with data already loaded, and the person data should follow the foaf and ex ontologies. 

For example, you can load RDF data like this into your triple store:
```
@prefix foaf: <http://xmlns.com/foaf/0.1/> .
@prefix ex: <http://example.com/> .

<http://example.com/person/1> a foaf:Person ;
    foaf:name "John Doe" ;
    ex:age 30 ;
    ex:occupation "Engineer" .

<http://example.com/person/2> a foaf:Person ;
    foaf:name "Jane Smith" ;
    ex:age 25 ;
    ex:occupation "Doctor" .
```
## Running the Code:
Ensure your triple store is running and contains the relevant RDF data.

Run the script: ```python derefTStore.py```.

Visit ```http://localhost:5000/person/1/info``` to see the RDF data for person 1 in Turtle format, dynamically fetched from the triple store.

On GitHub's codespace, add ```/person/1/info``` to the URL.

# With W3id
W3ID (Permanent Identifiers for the Web) is a service that provides stable, long-term identifiers for resources on the web. It is often used in the Linked Data community to ensure that URIs remain persistent, even if the underlying infrastructure changes. You can leverage W3ID to make your RDF URIs stable and dereferenceable.

To use W3ID in combination with a triple store and the Flask app, follow these steps:

## Steps:
Register a W3ID: First, register your permanent URI namespace with the W3ID service. This usually involves setting up a redirect that forwards requests from a w3id.org URI to your actual server.

For example, you could register ```https://w3id.org/example/person/``` to forward to ```http://example.com/person/```.

## Key Points in the Code (derefW3id.py):
**W3ID Namespace**: The W3ID_BASE_URI variable holds the base URI for the W3ID namespace (e.g., ```https://w3id.org/example/person/```). This ensures that the URIs in your RDF use the persistent W3ID identifiers.

**SPARQL Query**: The SPARQL query constructs triples where the subject is the W3ID URI (e.g., ```https://w3id.org/example/person/1```), ensuring the correct identifier is used in the RDF response.

**W3ID Redirect Setup**: You must configure W3ID so that requests to ```https://w3id.org/example/person/1``` are redirected to your Flask appâ€™s route (e.g., ```http://yourserver.com/person/1```). This can be done by creating a ```.htaccess``` file or similar redirect configuration in the W3ID GitHub repository.

## Example W3ID Redirect:
If you have registered ```https://w3id.org/example/person/``` with W3ID, you might set up a redirect so that a request to:
```
https://w3id.org/example/person/1
```
is forwarded to:
```
http://yourdomain.com/person/1
```
This allows the use of persistent URIs through W3ID, but the underlying resources are still hosted on your own infrastructure.

## Example SPARQL Query:
When the Flask app is accessed at ```http://localhost:5000/person/1/info```, it runs a SPARQL query like this:
```
PREFIX ex: <http://example.com/>
PREFIX foaf: <http://xmlns.com/foaf/0.1/>

CONSTRUCT {
    <https://w3id.org/example/person/1> a foaf:Person ;
                                        foaf:name ?name ;
                                        ex:age ?age ;
                                        ex:occupation ?occupation .
}
WHERE {
    <https://w3id.org/example/person/1> foaf:name ?name ;
                                        ex:age ?age ;
                                        ex:occupation ?occupation .
}

```
This ensures that the RDF triples returned use the W3ID URI as the subject, making them persistent and globally dereferenceable through the W3ID service.

## Summary:
**W3ID Registration**: Ensure you register your namespace with W3ID.

**URI Management**: Use W3ID URIs in your application to make your URIs stable and dereferenceable.

**Triple Store Queries**: Fetch the actual RDF data dynamically from your triple store while using W3ID URIs.

This approach combines the persistence of W3ID URIs with the dynamic querying capabilities of SPARQL and Python, ensuring that your RDF resources are both stable and flexible.

# Complete example like DBpedia dereferencing

```
python derefHTMLTSinMemory.py
```

On the GitHub codespace, add ```/person/1``` to the URL to see an example of data already loaded in a local triple store in memory.

## Access RDF Data (localhost):

Open your browser and go to:

```http://localhost:5000/person/1``` for John Doe

```http://localhost:5000/person/2``` for Jane Smith

```http://localhost:5000/person/3``` for Alice Johnson

We use as reference the W3C specification: [https://www.w3.org/2001/tag/doc/httpRange-14/2007-05-31/HttpRange-14](https://www.w3.org/2001/tag/doc/httpRange-14/2007-05-31/HttpRange-14)


